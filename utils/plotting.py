"""
Module containing plotting function for predictions
"""
import numpy as np
import pandas as pd
import plotly.graph_objects as go
import torch
from pytorch_forecasting.models import BaseModel
from pandas import DataFrame, Timestamp
from plotly.graph_objects import Figure
from typing import Dict, Any

def plot_country_prediction(model: BaseModel, predictions: Dict[str,Any], x: Dict[str,Any], idx: int, country_name: str,
                            day_zero: Timestamp, train_end: Timestamp=None) -> Figure:
    """
    Adapted prediction function to make plotly line chart for predictions and
    quantiles
    see https://plotly.com/python/line-charts/

    Args:
        model (BaseModel): model used for prediction
        predictions (Dict): predictions generated by model
        x (dict): information on covariaates returned by model prediction
        idx (int): index of country in model embbedding
        country_name (type): Name of country to be ussed in plot title
        day_zero (Timestamp): most recent date with known data
        train_end (Timestamp): most recent date in training data; if specified,
        end of training period will be marked in plot

    Returns:
        figure: plotly figure for prediction with quantiles

    """


  # these will be the same for all time series
    encoder_length: int = x["encoder_lengths"].tolist()[0]
    decoder_length: int = x["decoder_lengths"].tolist()[0]


  # get predictions and quantiles for country
    quantiles = model.loss.to_quantiles(predictions["prediction"])[idx]
    quantiles_t = torch.transpose(quantiles[:decoder_length, :x["decoder_lengths"][idx]], 0, 1).tolist()
    y_lower = quantiles_t[0]
    y_upper = quantiles_t[-1]

    pred_list = model.loss.to_prediction(predictions["prediction"])
    y_pred = pred_list[idx].detach().cpu()[: x["decoder_lengths"][idx]].tolist()

    y_known = x['encoder_target'][idx].tolist()

  # prepare ys and xs for correct display (see "Filled Lines" in plotly line chart docs)
    x_range = pd.date_range((day_zero - pd.DateOffset(days=encoder_length)).strftime("%Y-%m-%d"),
                    (day_zero + pd.DateOffset(days=decoder_length-1)).strftime("%Y-%m-%d"), freq="D").to_list()
    x_rev = x_range[-1::-1]
    y_known_p = y_known + (decoder_length*[np.nan])
    y_pred_p = (encoder_length*[np.nan]) + y_pred
    y_upper_p = (encoder_length*[np.nan]) + y_upper
    y_lower_p =  (encoder_length*[np.nan]) + y_lower

  # build plot
    y1 = y_known_p
    y1_upper = y_upper_p
    y1_lower = y_lower_p.copy()
    y1_lower = y1_lower[-1::-1]



    fig = go.Figure()

    fig.add_trace(go.Scatter(
        x=x_range+x_rev,
        y=y1_upper+y1_lower,
        fill='toself',
        fillcolor='rgba(0,100,80,0.2)',
        line_color='rgba(255,255,255,0)',
        showlegend=False

    ))

    fig.add_trace(go.Scatter(
        x=x_range,
        y=y1,
        name="Observed",
        showlegend=True
    ))

    fig.add_trace(go.Scatter(
        x=x_range,
        y=y_pred_p,
        line_color='rgb(0,100,80)',
        name='Predicted',
    ))

    fig.update_layout(
    title=country_name,
    xaxis_title="",
    yaxis_title="New Cases (7-day Avg.)",
    )

    if train_end:
        fig.add_vline(
            x=train_end,
            line_dash="dash",
            line_width=2,
            line_color="purple",
#             annotation_text = "End of Model Training Data",
#             annotation_position = "bottom right"
        )

        fig.add_annotation(
            x = train_end, #+ pd.DateOffset(days=2),
            y = max(y_known),
            text = "End of Model Training Data",
            showarrow=False,
            xshift= -80

        )

    return fig
